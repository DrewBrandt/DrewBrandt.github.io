{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This page written by ChatGPT. May not be accurate or helpful.</p>"},{"location":"#welcome-to-the-terrapin-rocket-teams-multi-mission-flight-software-mmfs-documentation","title":"Welcome to the Terrapin Rocket Team's Multi-Mission Flight Software (MMFS) Documentation","text":"<p>Welcome to the (maybe) official documentation site for TRT's Multi-Mission Flight Software (MMFS)\u2014the versatile and robust flight code framework developed by the Terrapin Rocket Team (TRT). Whether you're looking to integrate MMFS into your next mission, contribute to its ongoing development, or explore its unique capabilities, you've come to the right place!</p>"},{"location":"#what-is-mmfs","title":"\ud83d\ude80 What is MMFS?","text":"<p>MMFS is a modular and scalable flight software framework designed to meet the diverse needs of rocketry missions. Built with adaptability and reliability in mind, it provides a solid foundation for developing and deploying mission-critical systems. </p>"},{"location":"#explore-the-docs","title":"\ud83d\udcda Explore the Docs","text":"<p>This documentation is organized into three main sections to help you navigate the MMFS ecosystem:</p>"},{"location":"#1-getting-started","title":"1. Getting Started","text":"<ul> <li>Learn how to install MMFS and set it up as your base flight code framework.</li> <li>Step-by-step guides for configuring MMFS to meet your mission's requirements.</li> <li>Code snippets and examples to help you hit the ground running.</li> </ul>"},{"location":"#2-maintaining-mmfs","title":"2. Maintaining MMFS","text":"<ul> <li>Dive into the internals of MMFS to understand its architecture and core principles.</li> <li>Learn best practices for maintaining and updating the library.</li> <li>Contribution guidelines for those looking to improve MMFS.</li> </ul>"},{"location":"#3-miscellaneous-resources","title":"3. Miscellaneous Resources","text":"<ul> <li>Additional tools and utilities to enhance your development experience.</li> <li>Tips, tricks, and advanced usage scenarios.</li> <li>Frequently asked questions and troubleshooting.</li> </ul>"},{"location":"#features-at-a-glance","title":"\u2728 Features at a Glance","text":"<ul> <li>Modularity: Pick and choose components to fit your mission's needs.</li> <li>Scalability: From single-stage to multi-stage rockets, MMFS grows with your ambitions.</li> <li>Open Source: Join a community of rocketry enthusiasts and contribute to the future of MMFS.</li> </ul>"},{"location":"#ready-to-start","title":"\ud83c\udf1f Ready to Start?","text":"<p>Head over to the Getting Started section to begin your journey with MMFS. If you're a seasoned developer or contributor, check out the Maintaining MMFS section to dive deeper into the framework.</p> <p>Together, let's push the boundaries of rocketry innovation!</p>"},{"location":"maintainer-guide/","title":"Internal MMFS Maintenance Documentation","text":"CPPC <pre><code>/**\n * @file Logger.h\n * @brief This file contains the declaration of the Logger class, an example use case of the PSRAM and SdCardFile classes.\n * Based on the mode, the Logger class will write data to the PSRAM or the SD card, writing to the SD card when the mode is GROUND\n * and writing to the PSRAM when the mode is FLIGHT. The Logger class will also write data to the USB serial port when connected if\n * the destination is set to TO_USB or BOTH, which it is by default.\n */\n\n#ifndef LOGGER_H\n#define LOGGER_H\n\n\n#include \"psram.h\"\n#include \"../Constants.h\"\n#include \"SdFatBoilerplate.h\"\n#include &lt;stdarg.h&gt;\n#include \"../Events/Event.h\"\n\nnamespace mmfs\n{\n    class State;        // Forward declaration\n    class DataReporter; // Forward declaration\n    class GPS;\n\n    enum LogType\n    {\n        LOG_,\n        ERROR_,\n        WARNING_,\n        INFO_,\n        CUSTOM_,\n        NONE_\n    };\n\n    enum Dest\n    {\n        TO_FILE,\n        TO_USB,\n        BOTH\n    };\n\n    enum Mode\n    {\n        GROUND,\n        FLIGHT\n    };\n\n    enum GroundMode\n    {\n        SD_,\n        PSRAM_,\n        ALTERNATE_\n    };\n\n    class Logger\n    {\n\n    public:\n        Logger(); // store 30 seconds, print to SD every 30 seconds\n        virtual ~Logger();\n\n        virtual bool init(DataReporter **dataReporters, int numReporters, uint16_t bufferTime = 30, int bufferInterval = 30);\n\n        virtual bool isPsramReady() const;\n        virtual bool isSdCardReady();\n        virtual bool isReady() const;\n\n        void recordFlightData(); // records  flight data\n\n        // recordLogData with format string\n        void recordLogData(LogType type, Dest dest, int size, const char *format, ...);\n        void recordLogData(double timeStamp, LogType type, Dest dest, int size, const char *format, ...);\n        void recordLogData(LogType type, int size, const char *format, ...);\n        void recordLogData(int size, const char *format, ...);\n\n        // recordLogData with no format string\n        void recordLogData(LogType type, Dest dest, const char *msg);\n        void recordLogData(double timeStamp, LogType type, Dest dest, const char *msg);\n        void recordLogData(LogType type, const char *msg);\n        void recordLogData(double timeStamp, LogType type, const char *msg);\n\n        // Custom prefix\n\n        // use $time to wite 3 decimals of time data.\n        // ex: setLogPrefix(\"[$time] - CUSTOM\");\n        void setCustomLogPrefix(const char *prefix);\n        // use $time to wite 3 decimals of time data.\n        // ex: setLogPrefix(\"[$time] - CUSTOM\");\n        void setCustomLogPrefix(int size, const char *format, ...);\n\n        //use $time and $logType to access the time and log type of the current log.\n        // ex: setLogPrefix(\"[$time] - $logType:\"); -&gt; [0.000] - [INFO]: {log message}\n        void setLogPrefixFormatting(const char *prefix);\n\n        void setRecordMode(Mode mode);\n\n        void dumpData();\n\n        void writeCsvHeader();\n\n        void setPackData(bool pack)\n        {\n            if (!ready)\n                this-&gt;packData = pack;\n            else\n                recordLogData(WARNING_, \"Attempted to set PackData value after Logger already initalized!\");\n        }\n        void setGroundMode(GroundMode mode)\n        {\n            if (!ready)\n                this-&gt;groundMode = mode;\n            else\n                recordLogData(WARNING_, \"Attempted to set GroundMode value after Logger already initalized!\");\n        }\n        void setBufferTime(int time)\n        {\n            if (!ready)\n                this-&gt;bufferTime = time;\n            else\n                recordLogData(WARNING_, \"Attempted to set BufferTime value after Logger already initalized!\");\n        }\n        void setBufferInterval(int interval)\n        {\n            if (!ready)\n                this-&gt;bufferInterval = interval;\n            else\n                recordLogData(WARNING_, \"Attempted to set BufferInterval value after Logger already initalized!\");\n        }\n        bool getPackData() const { return packData; }\n        GroundMode getGroundMode() const { return groundMode; }\n        int getBufferTime() const { return bufferTime; }\n        int getBufferInterval() const { return bufferInterval; }\n\n        void modifyFileDates(const GPS *gps);\n\n    protected:\n        void recordLogData(double timeStamp, LogType type, Dest dest, int size, const char *format, va_list args);\n        void recordLogData(const char *msg, Dest dest = BOTH, LogType type = NONE_);\n        void recordCrashReport();\n        SdFs sd;\n        FsFile logFile;\n        FsFile flightDataFile;\n        FsFile preFlightFile;\n        PSRAM *psram;\n\n        //\n\n        Mode mode = GROUND;\n        DataReporter **dataReporters = nullptr;\n        int numReporters = 0;\n        GroundMode groundMode = ALTERNATE_;\n        bool packData = true;\n        uint16_t bufferTime;\n        int bufferInterval = 0;\n        char *logFileName = nullptr;        // Name of the log file\n        char *flightDataFileName = nullptr; // Name of the flight data file\n        char *preFlightFileName = nullptr;  // Name of the pre-flight file\n        bool sdReady = false;               // Whether the SD card has been initialized\n        bool psramReady = false;            // Whether the PSRAM has been initialized\n        bool ready = false;                 // Whether the logger is ready\n        bool hasFilledBuffer = false;       // Whether the ram buffer has been filled yet\n\n        //\n\n        PSRAMFile *ramFlightDataFile = nullptr; // Pointer to the flight data file\n        PSRAMFile *ramLogFile = nullptr;        // Pointer to the log file\n        PSRAMFile *ramBufferFile = nullptr;     // Pointer to the buffer file\n\n        int numBufferLines = 0;\n        int bufferIterations = 0;\n\n        //\n\n        char *logPrefixFormat = nullptr;\n        int logPrefixLen = 0;\n        char *customLogPrefix = nullptr;\n        int customLogPrefixLen = 0;\n        bool timeFirst = true;\n\n    };\n\n    Logger &amp;getLogger();\n    #ifdef PIO_UNIT_TESTING\n    void setLogger(Logger *logger);\n    #endif\n} // namespace mmfs\n\n#endif // LOGGER_H\n</code></pre> <pre><code>#include \"Logger.h\"\n</code></pre>"},{"location":"user-guide/basic-use/","title":"Basic Usage","text":"<p>Important!</p> <p>In order for PIO to recognize that you are working on a PIO project, you must open VSCode in the root directory of that project. that is, the directory that has the <code>platformio.ini</code> file in it. Without this, PlatformIO will not initialize and you will be unable to build or use proper Intellisense.</p>"},{"location":"user-guide/basic-use/#intro","title":"Intro","text":"<p>There are very few things that need to be done in order for the absolute minimum requirements to use MMFS to be met. You must: Extend the <code>State</code> class, pass it to an <code>MMFSSystem</code> object, and call the <code>init</code> and <code>update</code> methods during setup and loop, respectively. There are, of course, many more things that you can do to tailor MMFS to your preferences, but we'll start slow.</p>"},{"location":"user-guide/basic-use/#initial-integration","title":"Initial Integration","text":""},{"location":"user-guide/basic-use/#overriding-state","title":"Overriding <code>State</code>","text":"<p>Let's start by extending <code>State</code>. In your <code>src</code> folder, make a new set of files called something like <code>NewState.h</code> and <code>NewState.cpp</code>.</p> <p>Paste these contents into them:</p> NewState.hNewState.cpp <pre><code>#ifndef NEWSTATE_H\n#define NEWSTATE_H\n\n#include &lt;State/State.h&gt;\n\nusing namespace mmfs;\nclass NewState : public State {\n    public:\n        NewState(Sensor **sensors, int numSensors, Filter *filter);\n        void determineStage() override;\n};\n\n#endif\n</code></pre> <p><pre><code>#include \"NewState.h\"\n\nNewState::NewState(Sensor **sensors, int numSensors, Filter *filter) : State(sensors, numSensors, filter) {}\n\nvoid NewState::determineStage() // (1)!\n{\n    // Add whatever stage determination logic you'd like here.\n    // Here is one simplified example:\n    if (stage == 0 &amp;&amp; acceleration.z() &gt; 10 &amp;&amp; position.z() &gt; 20) \n    {                                                             // accelerating upwards and off the pad\n        stage = 1;                                                // ascent\n        getLogger().setRecordMode(FLIGHT);\n    }                                                             \n    else if (stage == 1 &amp;&amp; velocity.z() &lt; 0)                      // descending\n        stage = 2;                                                \n    else if (stage == 2 &amp;&amp; position.z() &lt; 20)                     \n    {                                                             // landed\n        stage = 3;\n        getLogger().setRecordMode(GROUND);\n    }\n}\n</code></pre></p> <ol> <li>You may have as many stages as you like, but MMFS expects you to have at least launch and land stages.</li> </ol> <p>Let's briefly talk about what we've done. <code>State</code> declares a method called <code>void determineStage()</code> that is called every time it updates. Only MMFS doesn't know which stages you might care about, so you have to tell it by overriding that function. The reason it's so important to detect launch and landing is because of those calls to <code>getLogger().setRecordMode()</code>. This changes the rate at which MMFS records data, but don't worry, we'll get to all of that. Just understand that this is an important method that must make those calls to <code>getLogger()</code> in order for data logging to work the way you want it to.<sup>1</sup></p>"},{"location":"user-guide/basic-use/#instantiating-the-state-object","title":"Instantiating the <code>State</code> object","text":"<p>Now that we have our <code>State</code> object with its <code>determineStage</code> method, we can head back over to the main file to finish our integration. We need to create an actual instance of the object for us to use in the <code>setup</code> and <code>loop</code> methods. You'll notice that in the constructor we implemented, it took a <code>Sensor **</code>. If you're not all that familiar with pointers, this is basically saying \"an array of pointers to <code>Sensor</code> objects\". This is because we need to pass in all of the sensors that we want to use. For now, let's just use the included 'IMU', 'GPS', and 'Barometer' sensors. We can do this by creating an array of pointers to <code>Sensor</code> objects, and then passing that to the <code>State</code> constructor. There was another important parameter, the <code>Filter</code>, which is a class that we haven't talked about yet. For now, we can just pass in <code>nullptr</code> for that parameter, as we don't need to use it right now.</p> main.cpp<pre><code>#include &lt;Arduino.h&gt;\n#include \"MMFS.h\"\n#include \"NewState.h\"\n\nMAX_M10S gps;\nDPS310 baro;\nBMI088andLIS3MDL imu9dof;\n\nSensor *sensors[] = {&amp;gps, &amp;baro, &amp;imu9dof};\n\nNewState state(sensors, 3, nullptr);\n\nvoid setup()\n{\n\n}\n\nvoid loop()\n{\n\n}\n</code></pre> <p>Here we've used the sensors that come on the Avionics' sub-team's Sensor Board v1.1, which anyone else on the team is also welcome to use. If you need to implement your own sensors, you can check out the Sensor documentation for more information.</p>"},{"location":"user-guide/basic-use/#creating-an-mmfsconfig-object","title":"Creating an <code>MMFSConfig</code> object","text":"<p>Now, we need to create an <code>MMFSConfig</code> object, which is a neat little object that follows what's called a \"builder pattern\". This means that we can set all of the configuration options that we want, while leaving out the options we don't care about. For our use case, the only thing we need to send it is the state object, but we'll set up a couple other things as well so you get an idea of the object's versatility. Here's what that looks like:</p> main.cpp<pre><code>...\nSensor *sensors[] = {&amp;gps, &amp;baro, &amp;imu9dof};\n\nNewState state(sensors, 3, nullptr);\n\nMMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN);\n\nvoid setup()\n{\n...\n</code></pre> <p>So here, we're just setting the buzzer pin to 13 and the built-in LED pin to <code>LED_BUILTIN</code>, which is a constant that is defined in the Arduino framework. You can set any of the configuration options that you want by appending their methods to the end of the list, but for now, we'll just leave it at that. See the MMFSConfig documentation for more information.</p>"},{"location":"user-guide/basic-use/#creating-an-mmfssystem-object","title":"Creating an <code>MMFSSystem</code> object","text":"<p>Now that we have our config, we need ot actually create the <code>MMFSSystem</code> object. This is a simple one-liner:</p> main.cpp<pre><code>...\nMMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN);\n\nMMFSSystem system(config);\n\nvoid setup()\n{\n...\n</code></pre>"},{"location":"user-guide/basic-use/#calling-init-and-update","title":"Calling <code>init</code> and <code>update</code>","text":"<p>Now, we just need to call the <code>init</code> and <code>update</code> methods in the <code>setup</code> and <code>loop</code> methods, respectively. MMFS will take care of everything else. Yes, really. This is all the code oyu need to write to get a minimum working system up and running. </p> New codeFull main.cpp main.cpp<pre><code>MMFSSystem computer = MMFSSystem(&amp;config);\n\nvoid setup()\n{\n  computer.init();\n}\n\nvoid loop()\n{\n  computer.update();\n}\n</code></pre> <pre><code>#include &lt;Arduino.h&gt;\n#include \"MMFS.h\"\n#include \"NewState.h\"\n\nMAX_M10S gps;\nDPS310 baro;\nBMI088andLIS3MDL imu9dof;\n\nSensor *sensors[] = {&amp;gps, &amp;baro, &amp;imu9dof};\n\nNewState state(sensors, 3, nullptr);\n\nMMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN);\n\nMMFSSystem computer = MMFSSystem(&amp;config);\n\nvoid setup()\n{\n  computer.init();\n}\n\nvoid loop()\n{\n  computer.update();\n}\n</code></pre>"},{"location":"user-guide/basic-use/#conclusion","title":"Conclusion","text":"<p>That's it! You now have a fully functional MMFS system that is ready to be used. You can add more sensors, change the configuration options, and customize the <code>State</code> class to your heart's content. See the MMFSConfig documentation for more information on what you can do with the config object, and see the State documentation for more information on how to customize the state object.</p>"},{"location":"user-guide/basic-use/#easy-modifications","title":"Easy Modifications","text":"<p>Here are few easy modifications that you can make to the system to make it more suited to your needs. If you don't see what you're looking for here, try the page relating to the specific feature you're looking for, or the Advanced Usage page.</p>"},{"location":"user-guide/basic-use/#modifying-the-update-rate","title":"Modifying the update rate","text":"<p>You can modify the update rate of the system by using one of two methods on the MMFS Config object. They both have the same effect, and the last one called is the one used.</p> withUpdateRate()withUpdateInterval() <pre><code>MMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN)\n                        .withUpdateRate(10); // 10Hz (100 ms between updates)\n</code></pre> <pre><code>MMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN)\n                        .withUpdateInterval(100); // 100ms between updates (10Hz)\n</code></pre> <p>Note</p> <p>10 hz is the default rate. If you set it too high, the system may struggle to keep up, so we recommend keeping it at 50 hz or lower.</p>"},{"location":"user-guide/basic-use/#sensor-drift-correction","title":"Sensor drift correction","text":"<p>While on the pad waiting for launch, it is very likely that the sensors will begin to drift slightly. There is a feature in MMFS that allows you to correct for this until launch is detected. This correction acts by averaging out some length of sensor data, while ignore the very most recent data. As most launch detection systems require the rocket to be noticeably off the ground and may take a few iterations to properly detect launch, the idea behind this was to stop launch data from affecting the zeroing of the sensors.</p> <p>Danger</p> <p>Using this feature requires that you have working launch detection. If not, they will continuously attempt to correct themselves to zero, and thus report faulty data for the duration of the flight.</p> <p><pre><code>MMFSConfig config = MMFSConfig()\n                        .withState(&amp;state)\n                        .withBuzzerPin(13)\n                        .withBBPin(LED_BUILTIN)\n                        .withUsingSensorBiasCorrection(true); // (1)!\n                        .withSensorBiasCorrectionDataLength(2); // two seconds of data to average over, BUT\n                        .withSensorBiasCorrectionIgnore(1); // ignore the most recent 1 second of data.\n</code></pre></p> <ol> <li>This is false by default, however the length of collection and ignoring default to the two values below, meaning you do not have to call the methods if these values are fine for you.</li> </ol>"},{"location":"user-guide/basic-use/#using-blinkbuzz","title":"Using BlinkBuzz","text":"<p>As we saw earlier, you must add the signaling pins you want to use to the <code>MMFSConfig</code> object. This is done by calling the <code>withBuzzerPin()</code> and <code>withBBPin()</code> methods. The buzzer pin is special and has some default events that utilize it. <code>withBBPin()</code> can be use to add any pin (or a second buzzer). You can add up to 50 pins.</p> <p>To use a pin, you can call <code>bb.onoff(int pin, int duration, int repeat = 1, int pause = duration)</code>. If you are in the <code>loop</code> phase of the program, you can use <code>bb.aonoff(...)</code> to do the same thing asynchronously.</p> <p>See the BlinkBuzz documentation for more usage information.</p>"},{"location":"user-guide/basic-use/#using-the-logger","title":"Using the Logger","text":"<p>You can modify the format of the event logger by using the <code>withLogPrefixFormatting()</code> method. This takes a string that must include the <code>$time</code> and <code>$logType</code> (case specific) keywords. It will then format all log entries accordingly. The default is </p> <p><code>\"$time - [$logType] \"</code></p> <p>To use the logger to record data, you can call <code>getLogger().log(LogType type, const char *format, ...)</code>. This will log the data to both the SD card and USB serial port.</p> <p>See the Logger documentation for more information.</p>"},{"location":"user-guide/basic-use/#conclusion_1","title":"Conclusion","text":"<p>This just scratches the surface of what these utilities and systems can handle (blink buzz can do infinite morse code! ...if you need that).</p> <p>See the MMFSConfig documentation for more information on what you can do with the config object.</p> <p>See the State documentation for more information on how to customize the state object.</p> <p>Also check out the Event system, Sensor interface, DataReporter interface, and Filter interface for more information on how to use some more advanced parts of the system.</p> <ol> <li> <p>There are other configuration options that you can use to disregard the stage system, but we don't recommend it. Check out the Logger documentation for more information.\u00a0\u21a9</p> </li> </ol>"},{"location":"user-guide/installation/","title":"Installation","text":"<p>You may skip over this installation step if you are working in a repo that already uses MMFS and you are just looking to get introduced.</p> <p>Important!</p> <p>In order for PIO to recognize that you are working on a PIO project, you must open VSCode in the root directory of that project. that is, the directory that has the <code>platformio.ini</code> file in it. Without this, PlatformIO will not initialize and you will be unable to build or use proper Intellisense.</p>"},{"location":"user-guide/installation/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have the following:</p> <ul> <li>Basic knowledge of C++ programming. (knowledge of what a pointer is and how to use one)</li> <li>VSCode and the PlatformIO (PIO) extension installed. [Installation Guide]</li> <li>Basic knowledge of VSCode and the PlatformIO interface [Interface cheat-sheet]</li> <li>Basic knowledge of Git and GitHub. [TRT Git/Github Guide]</li> <li>Access to a Teensy 4.1. </li> </ul>"},{"location":"user-guide/installation/#installation","title":"Installation","text":""},{"location":"user-guide/installation/#create-a-new-platformio-project","title":"Create a new PlatformIO project","text":"<p>Pick any folder to create it in, and create a new project. We strongly recommend choosing the arduino framework and the Teensy 4.1 board, as MMFS has not been tested on any other system.</p>"},{"location":"user-guide/installation/#modify-the-platformioini-file","title":"Modify the <code>platformio.ini</code> file","text":"<p>Add a dependency to MMFS by adding the highlighted lines to your <code>platformio.ini</code> file, found in your project's root directory. <pre><code>[env:teensy41]\nplatform = teensy\nboard = teensy41\nframework = arduino\nlib_deps =\n    https://github.com/Terrapin-Rocket-Team/Multi-Mission-Flight-Software.git#v3.0.0\n</code></pre></p> <p>Info</p> <p>You may add multiple dependencies by appending new indented lines under <code>lib_deps</code>.</p> <p>Tip</p> <p>We recommend always attaching the version specifier to the end of the url, as MMFS undergoes frequent breaking changes. For github links, this looks like <code>#{tag}</code>. We give our releases (a.k.a. tags) semantic versioning<sup>1</sup> numbers like <code>v3.0.0</code></p> <p>Now save the file. You should notice PIO start to download MMFS and all of its dependencies. It may take a few minutes.</p>"},{"location":"user-guide/installation/#add-mmfsh-to-maincpp","title":"Add <code>MMFS.h</code> to <code>main.cpp</code>","text":"<p>Looking at the folder structure, PIO should have created a <code>src</code> folder with a <code>main.cpp</code> in it. It has some basic example functions that you may ignore or delete. To link MMFS to this main file though, we need to <code>#include</code> it:</p> <pre><code>#include &lt;Arduino.h&gt;\n#include &lt;MMFS.h&gt;\n\n// put function declarations here:\nint myFunction(int, int);\n</code></pre>"},{"location":"user-guide/installation/#build-the-project","title":"Build the project","text":"<p>The last thing to do to make sure that everything went well is to simply build the project.</p> <p>You can use any of PIO's <code>build</code> buttons to achieve this. If you don't know where the buttons are, we recommend using the toolbar on the bottom of the screen, where the <code>build</code> command is represented by the checkmark.</p> <p>The terminal should spit out <code>========[SUCCESS] Took ##.## seconds=======</code>. If not, first try and see if you can understand the error. If you get stuck, please feel free to message any of the club members with experience working in PlatformIO or MMFS.</p>"},{"location":"user-guide/installation/#conclusion","title":"Conclusion","text":"<p>That's all there is to installing the library. You're now ready to move on to using it! Hopefully that part will be just as straightforward.</p> <ol> <li> <p>We always use this format, but we don't always follow correct semantic versioning procedures.\u00a0\u21a9</p> </li> </ol>"},{"location":"user-guide/intro/","title":"The Complete MMFS User's Manual","text":"<p>Info</p> <p>These docs were written in the order shown on the sidebar. You many notice that later docs somewhat rely on the reader understanding topics covered earlier. They should mostly be self-sufficient, but it's not guaranteed.</p> <p>As always, if you have any questions, feel free to reach out on Slack or Github.</p> <p><sub><sup><sub><sup>Now on a cool new website!</sup></sub></sup></sub></p> <p>This is the (maybe) official user's manual for TRT's Multi-Mission Flight Software (MMFS). It is designed to be a comprehensive guide for users of all levels, from beginners to advanced developers. The manual covers everything from installation and setup to advanced features and troubleshooting.</p> <p>The library is essentially split into two categories: Utilities and Interfaces. </p>"},{"location":"user-guide/intro/#utilities","title":"Utilities","text":"<p>We describe utilities as any part of the library designed to be used as-is, without the end user (you) having to overload or otherwise modify it. The utilities offered by MMFS are:</p>"},{"location":"user-guide/intro/#blinkbuzz","title":"BlinkBuzz","text":"<p><sup>An (asynchronous!) utility for outputting patterned buzzes and LED blinks.</sup></p>"},{"location":"user-guide/intro/#circbuffer","title":"CircBuffer","text":"<p><sup>A queue or FIFO system for storing data in a fixed-size buffer.</sup></p>"},{"location":"user-guide/intro/#errorhandler","title":"ErrorHandler","text":"<p><sup>Uses Logger under-the-hood to log errors to the SD card and USB serial port.</sup></p>"},{"location":"user-guide/intro/#logger","title":"Logger","text":"<p><sup>A simple logging utility that can log to the SD card or USB serial port.</sup></p>"},{"location":"user-guide/intro/#math","title":"Math","text":"<p><sup>A collection of ... math? ... objects (vectors, matrices, and quaternions) and their functions.</sup></p>"},{"location":"user-guide/intro/#mmfssystem","title":"MMFSSystem","text":"<p><sup>An object designed to handle all of the MMFS functions during flight.</sup></p> <p>Most of the power that MMFS offers comes from the Logger and MMFSSystem utilities. That is to say, those are two of the most complicated systems in the library.</p>"},{"location":"user-guide/intro/#interfaces","title":"Interfaces","text":"<p>Interfaces are for any other part of the library that is not fully implemented, or otherwise is expected to be modified by the end user. Most of them are not strictly interfaces, but rather abstract classes. The following interfaces are offered by MMFS:</p>"},{"location":"user-guide/intro/#state","title":"State","text":"<p><sup>This is the main purpose of using MMFS. It is an abstract class that is used to define the state of the rocket. It is designed to be overloaded by the end user, and is used to define the behavior of the telemetry systems during flight.</sup></p>"},{"location":"user-guide/intro/#datareporter","title":"DataReporter","text":"<p><sup>This is an interface for recording flight CSV data using Logger. State implements it, as do all of the sensors. You may extend it to add your own data reporters.</sup></p>"},{"location":"user-guide/intro/#sensor","title":"Sensor","text":"<p><sup>This is the base sensor interface. There are further interfaces for each type of sensor:</sup></p> <ul> <li>Barometer</li> <li>IMU (9DOF, including accelerometer, gyroscope, and magnetometer)</li> <li>GPS</li> <li>Encoder (a motor encoder)</li> <li>LightSensor</li> <li>RTC (we don't currently use this, so it is not implemented)</li> </ul>"},{"location":"user-guide/intro/#actuator","title":"Actuator","text":"<p><sup>This is the base actuator interface. They differ from sensors in that they are not expected to record data, only act on it.</sup></p>"},{"location":"user-guide/intro/#event","title":"Event","text":"<p><sup>This is a simple, readily-extendable event system. You can create classes that listen to and fire off custom events, or overload the handler for the default events.</sup></p>"},{"location":"user-guide/intro/#filters","title":"Filters","text":"<p><sup>This is a basic Kalman filter interface, able to be passed into State for it to use to filter sensor data.</sup></p>"},{"location":"user-guide/utils/blinkbuzz/","title":"BlinkBuzz","text":"<p>This utility is designed to be used as-is, without the end user (you) having to overload or otherwise modify it. It is an asynchronous utility for outputting patterned buzzes and LED blinks. It can be used to create simple patterns, such as beeping a certain number of times, or more complex patterns, such as SOS in morse code. It can also be used to create patterns that repeat indefinitely, or patterns that repeat a certain number of times. It is designed to be easy to use and flexible enough to handle a wide variety of use cases.</p>"},{"location":"user-guide/utils/blinkbuzz/#setup","title":"Setup","text":"<p>We strongly recommend that you use the <code>MMFSSystem</code> and <code>MMFSConfig</code> objects whenever you use MMFS. That said, all utilities have the ability to be used outside of <code>MMFSSystem</code>, including BlinkBuzz. The only difference between the two is the setup. All other functions are identical.</p> With MMFSSystemWithout MMFSSystem <p>BlinkBuzz does not have too many configuration options. Here they are, shown with their default values if they have them:</p> <pre><code>#include &lt;MMFS.h&gt;\n\nint GPS_STATUS_PIN = 25;\n\nMMFSConfig config = MMFSConfig()\n                    .withBuzzerPin(33) // no default\n                    .withBBPin(LED_BUILTIN) // add any pin you'd like, no default\n                    .withBBPin(GPS_STATUS_PIN) // add as many pins as you want, no default\n                    .withBBAsync(true, 50); // allow async patterns, max queue size of 50.\n\nMMFSSystem system = MMFSSystem(config);\n</code></pre> <p>In <code>setup()</code> you must call <code>system.init()</code> to initialize the system. This will also initialize the BlinkBuzz utility.</p> <p>In order to take advantage of the async features, you must call <code>system.update()</code> in your <code>loop()</code>. This will also update the BlinkBuzz utility.</p> <p>If you do not wish to use the MMFSSystem, you can use BlinkBuzz as a standalone utility. You must however set up the object yourself, and remember to call <code>bb.update()</code> in your <code>loop()</code>. </p> <pre><code>#include &lt;BlinkBuzz.h&gt;\n\nint *allowedPins[] = { LED_BUILTIN, 33 };\nBlinkBuzz bb; //define a global variable that is declared in the Blinkbuzz.h file for easy access across files\n\nsetup() {\n    bb.init(allowedPins, 2, true, 50); // allowed pins, number of pins, allow usage of async patterns, Max queue size per pin (async mode only)\n    //NOTE: Max queue size refers to the number of on and off toggles that are performed, so ON -&gt; OFF is 2 spots in the queue.\n}\n\nloop()\n{\n    bb.update(); // The more frequently this is called, the more accurate the timing will be.\n\n    // We recommend not using a delay() call for loop iterations when using async patterns.\n    // Instead, maybe try something like this:\n    double time = millis();\n    if(time - lastTime &gt; DESIRED_INTERVAL) { // however much you would have otherwise delay()ed for\n        lastTime = time; // lastTime = global variable declared elsewhere\n        // the rest of your loop code here\n}\n</code></pre> <p>Warning</p> <p>There is a moderate memory overhead associated with using async patterns. Keep queue sizes as small as is reasonable.</p>"},{"location":"user-guide/utils/blinkbuzz/#usage","title":"Usage","text":"<p>In any file that includes BlinkBuzz, you can use any of the BlinkBuzz functions. </p>"},{"location":"user-guide/utils/blinkbuzz/#synchronous-usage","title":"Synchronous usage","text":"<p>These are the calls you would make while in <code>setup()</code> or if you disable async usage.</p> <p>Note</p> <p><code>BBPattern</code> arguments are not supported in synchronous function calls, nor are they planned to be in the future.</p> <pre><code>#include &lt;BlinkBuzz.h&gt;\n\nvoid setup() {\n\n    // Simply hold the pin on/off:\n    bb.on(BUZZER);  // turn on\n    bb.off(BUZZER); // turn off\n\n    //Patternize\n    bb.onoff(BUZZER, 200, 3, 100); // beep 3 times, 200ms on, 100ms off\n    // OR\n    bb.onoff(BUZZER, 200, 5);      // beep 5x, 200ms on, 200ms off\n    // OR\n    bb.onoff(BUZZER, 200);         // beep 1x, 200ms on\n}\n</code></pre>"},{"location":"user-guide/utils/blinkbuzz/#async-usage","title":"Async Usage","text":"<p>Asynchronous use was the reason BlinkBuzz came to be in the first place, and is what makes the utility so valuable and powerful. You can blink lights in custom patterns indefinitely, without blocking the rest of your code. This is invaluable during testing as the buzzer can beep to indicate state changes without stopping the State from updating.</p>"},{"location":"user-guide/utils/blinkbuzz/#old-school","title":"Old-School","text":"<p>Here are the most basic examples of how to use the async functions: <pre><code>    bb.aonoff(BUZZER, 200, 3, 100); // beep 3 times, 200ms on, 100ms off\n    // OR\n    bb.aonoff(BUZZER, 200, 5);      // beep 5x, 200ms on, 200ms off\n    // OR\n    bb.aonoff(BUZZER, 200);         // beep 1x, 200ms on\n\n    // Can clear a pin's queue:\n    bb.clearQueue(BUZZER);\n</code></pre></p>"},{"location":"user-guide/utils/blinkbuzz/#bbpattern","title":"BBPattern","text":"<p>You can also use the <code>BBPattern</code> class to build complex patterns. You define a pattern  with the same arguments as <code>onoff()</code>, but you can also append patterns to each other, and add \"rests\" to the end of a pattern. You may then call the pattern with <code>aonoff()</code> with any pin.</p> <pre><code>    BBPattern pattern = BBPattern(ON_DURATION, REPEATS, OFF_DURATION);\n    // For example, to build an SOS pattern, build the S and O letters:\n    BBPattern s(50, 3, 200);\n    BBPattern o(500, 3, 200);\n    // Then, append them to each other to build a single SOS pattern using the `a()` function:\n    BBPattern sos;\n    sos.a(s).a(o).a(s);\n    //NOTE: do not do BBPattern sos = s.a(o).a(s); as this will not work as expected. Minor bug.\n    // Then call it\n    bb.aonoff(BUZZER, sos);\n\n    // To repeat a pattern indefinitely, use the following:\n    bb.aonoff(BUZZER, sos, true);\n\n    // You can also append a \"rest\" to the end of a pattern, changing it's final duration.\n    bb.aonoff(BUZZER, sos.r(1000), true); // Rest for 1 second between the SOS patterns\n    //The rest can be added inline like this or to the pattern object itself.\n\n    // Appending patterns and adding rests can be done in any order as many times as you wish (so long as you have the queue space to hold them)\n}\n</code></pre>"},{"location":"user-guide/utils/circbuf/","title":"CircBuffer","text":"<p>This class is exactly what it sounds like. It uses an array based implementation of a queue to hold a buffer of any kind of object. Internally, it's used as part of the Sensor drift correction system to store data for averaging, but it can realistically be used for anything.</p>"},{"location":"user-guide/utils/circbuf/#usage","title":"Usage","text":"<p>Initialization and adding/removing: <pre><code>#include &lt;CircBuffer.h&gt;\n\n// Create a circular buffer of 10 integers\nCircBuffer&lt;int&gt; buffer(10);\n// Add an element to the buffer\nbuffer.push(1);\n// See top of the queue\nint top = buffer.peek();\n// Pop an element from the buffer\nint popped = buffer.pop();\n</code></pre></p> <p>There are also these other standard functions, that do about what you'd expect: <pre><code>bool isEmpty();\nbool isFull();\nint getSize(); // capacity of buffer\nint getCount(); // number of elements in buffer\nvoid clear();\n</code></pre></p> <p>Finally, you can use the <code>[]</code> operator to access elements. <code>buffer[0]</code> is the top of the queue, and <code>buffer[buffer.getCount() - 1]</code> is the bottom.</p>"},{"location":"user-guide/utils/error/","title":"ErrorHandler","text":"<p>The ErrorHandler class stores a list of all errors that have occurred. It's our solution to not being able to throw errors due to the memory overhead that standard errors incur. They are logged when they happen, and can be passed an integer (such as line number) to help with debugging.</p> <p>There is a global <code>errorHandler</code> object that can be used to log errors. To add an error to it, simply do <pre><code>#include &lt;ErrorHandler.h&gt;\n\nerrorHandler.addError(ErrorType type, const char *message, int line);\n</code></pre> Where <code>ErrorType</code> is an enum of the following: <pre><code>GENERIC_ERROR,\nNONCRITICAL_WARNING,\nSOFTWARE_ERROR,\nHARDWARE_ERROR,\nCRITICAL_ERROR\n</code></pre> You can also use BlinkBuzz by appending a pin number and a <code>BBPattern</code><sup>1</sup> pointer to the end of the method call: <pre><code>errorHandler.addError(ErrorType type, const char *message, int line, int pin, BBPattern *pattern);\n</code></pre> This will cause the pattern to be played on the pin when the error is logged. This is useful for debugging, as you can use different patterns to indicate different errors.</p> <p>Finally, while the erros are logged at time of occurrence, if you need to print a list of them, you can call: <pre><code>errorHandler.printErrors();\n</code></pre></p> <p>Note</p> <p>Events have not yet been integrated with the error handler, so no event is fired when an error is logged.</p> <ol> <li> <p>BBPattern from BlinkBuzz \u21a9</p> </li> </ol>"},{"location":"user-guide/utils/logger/","title":"Logger","text":"<p>Note</p> <p>It is very likely that this class has minor changes to to the way it is set up in the future. Please verify that the footer indicates the correct MMFS version number.</p> <p>The Logger class is one of the most powerful, but also one of the most complicated systems in MMFS. It can take both log data and flight data and write them to the SD card or USB. By default, it can use the PSRAM as an intermediary during flight to ensure that \"slow\" SD card writes do not interfere with data processing. It (by default) performs less frequent writes during pre- and post-flight periods to prevent writing unnecessary data. It also (by default) compresses data to save PSRAM space. Additionally, it can modify the date of file creation so it is accurate once an onboard GPS obtains a time fix. Finally, it will log any crashes that happen the next time it boots up.</p> <p>With all this functionality, there are numerous configuration options to choose from, so feel free to jump to a specific section using the table of contents on the right.</p>"},{"location":"user-guide/utils/logger/#setup","title":"Setup","text":"<p>The first thing to know about the Logger class is that it exists as a singleton, accessed via the global <code>getLogger()</code> method. Every time you need to use any of the Logger\u2019s functions, you should prefix them with <code>getLogger()</code> followed by the function call.</p> <p>We strongly recommend using the <code>MMFSSystem</code> and <code>MMFSConfig</code> objects whenever you use MMFS, as they handle almost all initialization tasks for you. However, all utilities can be used outside of <code>MMFSSystem</code>, including Logger. The only difference between these two approaches is the setup. All other functions are identical.</p> With MMFSSystemWithout MMFSSystem <p>Here is a list of the <code>MMFSConfig</code><sup>1</sup> options relevant to Logger:</p> BeginnerAdvanced <p>These defaults should be fine for most use cases. The defaults are shown below:</p> <pre><code>#include &lt;MMFS.h&gt;\n\nMMFSConfig config = MMFSConfig()\n                    .withCompressedFlightData(true) // Compress flight data to save PSRAM space\n                    .withUsePSRAM(true) // Use PSRAM as an intermediary during flight\n                    .withReducedPreFlightDataRate(true, 30) // Reduce SD card writes in pre-/post-flight to once every 30 seconds\n                    .withPreFlightBuffer(true, 30) // Buffer pre-/post-flight data to the PSRAM (30 seconds worth)\n                    .withOtherDataReporters(DataReporter **others) // Add additional objects that can report flight data\n                    .withLogPrefixFormatting(\"$time - [$logType] \"); // Change format string for log data (must include $time and $logType)\n</code></pre> <p>It is unlikely you will need to change these options, but they are available:</p> <pre><code>#include &lt;MMFS.h&gt;\n\nMMFSConfig config = MMFSConfig()\n                    .withMaxPSRAMFiles(5);\n// Maximum number of files that the FAT-like PSRAM file system can hold. \n// There are three files currently stored on it by MMFS. Maximum is 255.\n</code></pre> <p>If you simply want to use Logger without <code>MMFSSystem</code>, you need to call <code>getLogger().init()</code> with the default parameters. You must pass all the DataReporter objects (including State and all its sensors) and their count. You can also pass in the buffer time and buffer interval variables. Check if it worked with <code>getLogger().isReady()</code>. At the end of setup (after all of the data reporters are initialized), you should call <code>getLogger().writeCsvHeader()</code> to write the initial line to the SD card.</p> <pre><code>#include &lt;Logger.h&gt;\n\nsetup() {\n    // Example:\n    // DataReporter *reporters[] = { &amp;state, &amp;sensor1, &amp;sensor2, ... };\n    // getLogger().init(reporters, numberOfReporters, 30, 30);\n    // if (getLogger().isReady()) {\n    //     getLogger().writeCsvHeader();\n    // }\n}\n</code></pre>"},{"location":"user-guide/utils/logger/#recording-log-data","title":"Recording Log Data","text":""},{"location":"user-guide/utils/logger/#before-you-begin","title":"Before You Begin","text":"<p>All log data is recorded to a file called <code>log.txt</code>. It prefixes all log entries with a timestamp and a log type. The log types are:</p> <ul> <li><code>INFO_</code>: General system information (default).</li> <li><code>WARNING_</code>: A warning about a potential issue.</li> <li><code>ERROR_</code>: An error that has occurred.</li> <li><code>LOG_</code>: A log entry that is not an error or warning.</li> <li><code>CUSTOM_</code>: A log entry with a custom prefix.</li> </ul> <p>You can change the format of the default log types before calling <code>getLogger().init()</code> by calling:</p> <pre><code>getLogger().setLogPrefixFormatting(const char *prefix);\n</code></pre> <p>The default is <code>\"$time - [$logType] \"</code>, which will produce something like <code>0.000 - [INFO] Hello, world!</code>. When you call this function, you must include the keywords <code>$time</code> and <code>[$logType]</code>. <code>$time</code> is replaced with the time (in seconds) since the microcontroller turned on (printed with 3 decimal places), and <code>[$logType]</code> is replaced with the log type stamp. You can include any additional text you like.</p> <p>You may change the log prefix for the custom log type by calling:</p> <pre><code>getLogger().setCustomLogPrefix(const char *prefix);\n</code></pre> <p>The default is <code>\"$time - [CUSTOM] \"</code>, which would output something like <code>0.000 - [CUSTOM] Hello, world!</code>. Including <code>$time</code> is recommended but not required. This method can be called at any time, and the custom prefix will remain until overridden by a subsequent call.</p> <p>When you record log data, you can send it to the SD card, USB serial, or both. The default behavior is to record to both. These options exist in the <code>Dest</code> enum:</p> <pre><code>enum Dest {\n    TO_FILE,\n    TO_USB,\n    BOTH\n};\n</code></pre>"},{"location":"user-guide/utils/logger/#recording-data","title":"Recording Data","text":"<p>Once setup is complete, you can record log data using:</p> <pre><code>getLogger().recordLogData(...);\n</code></pre> <p>There are eight different function overloads for this method, each taking different arguments. Essentially, you specify the log type, where you want to send it (destination), and the actual data you want to log. You can optionally supply a timestamp instead of letting it be generated automatically, and you can choose to use or not use a printf-style format string followed by any number of arguments. Rather than list every overload, here are a couple of examples:</p> <pre><code>getLogger().recordLogData(WARNING_, TO_USB, \"Hello, world!\");\ngetLogger().recordLogData(INFO_, TO_FILE, 50, \"Hello %s\", \"there!\");\n</code></pre> <p>Note</p> <p>If you use the format string versions of the method, you must provide an integer representing the maximum length you expect the string to be once formatted.</p> <p>Once the data is logged to its destination, Logger will fire a <code>LogData</code> event with the ID <code>\"LOG_DATA\"_i</code><sup>2</sup>. You can listen for this event if you want to do something additional with the logged data.</p>"},{"location":"user-guide/utils/logger/#recording-flight-data","title":"Recording Flight Data","text":""},{"location":"user-guide/utils/logger/#before-you-begin_1","title":"Before You Begin","text":"<p>Flight data is stored in two files: a preflight data file and a flight data file. By default, it only stores pre- and post-flight data once every 30 seconds. This is why having a robust State with proper launch detection is important. By default, it also stores the most recent 30 seconds of data before launch at the full data rate. You can change this behavior by modifying the buffer time and buffer interval parameters in the init function. To write all data directly to the SD card, set the buffer interval to zero. To write no data to the SD card and store everything in PSRAM until landing is detected, set the buffer interval to less than zero.</p> <p>Another feature of Logger is that it compresses data during flight to save PSRAM space when there is a long flight or many data reporters. This is enabled by default but can be disabled by setting the <code>bufferTime</code> parameter to 0 in the <code>init</code> function.</p> <p>Warning</p> <p>Disabling these features is currently in an experimental state and may not work as expected.</p> <p>Note</p> <p>If the system detects that there is no PSRAM, it will automatically write all data to the SD card.</p> <p>All functionality surrounding flight and preflight data is managed by an internal enum called <code>Mode</code>. By default, the mode is <code>GROUND</code>. Once you call:</p> <pre><code>getLogger().setMode(FLIGHT);\n</code></pre> <p>the Logger assumes the rocket has just launched and switches into flight mode. When landing is detected, simply call:</p> <pre><code>getLogger().setMode(GROUND);\n</code></pre> <p>and the Logger will switch back to pre-/post-flight data mode.</p>"},{"location":"user-guide/utils/logger/#recording-data_1","title":"Recording Data","text":"<p>If you use the MMFSSystem objects, this is done automatically when you call <code>system.update()</code> in your loop. If you are not using the MMFSSystem objects, you must call:</p> <pre><code>getLogger().recordFlightData();\n</code></pre> <p>in your loop to record flight data. This method automatically detects the mode and logs the appropriate data. The order of columns in the CSV file is determined by the order of the data reporter objects passed to the Logger. If you use MMFSSystem, this will be the State followed by all sensors in the order they were passed to the State, then anything else added later.</p>"},{"location":"user-guide/utils/logger/#miscellaneous","title":"Miscellaneous","text":""},{"location":"user-guide/utils/logger/#changing-the-creation-date-of-files","title":"Changing the Creation Date of Files","text":"<p>Unfortunately, the SD card itself has no concept of real-world time. However, most flight systems have a GPS onboard, and by taking advantage of the default GPS event, MMFS will attempt to set correct creation and modification dates for all files on the SD card, making them easier to manage later. This is handled by default through the default event handler<sup>2</sup>. If you disabled the default event handler, you can still modify file dates by calling:</p> <pre><code>getLogger().modifyFileDates(GPS *gps);\n</code></pre>"},{"location":"user-guide/utils/logger/#crashreport","title":"CrashReport","text":"<p>This is another feature of Logger. It has no configuration options, but it is helpful to have. If the Teensy detects a crash, a crash report object is created, and the Logger will attempt to record it in the <code>log.txt</code> file on the next boot.</p> <ol> <li> <p>MMFSConfig from MMFSSystem \u21a9</p> </li> <li> <p>Event \u21a9\u21a9</p> </li> </ol>"},{"location":"user-guide/utils/math/","title":"Math","text":""},{"location":"user-guide/utils/math/#matrix","title":"Matrix","text":"<p>The Matrix class is designed for use with Coleman filters. It is based on a simple array of doubles and supports most matrix operations, including addition, subtraction, multiplication, transposition, and inversion.</p> <pre><code>#include &lt;Math.h&gt;\n\n// Dynamically allocate memory for a 3x3 matrix\ndouble* data = new double[3 * 3]{\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n};\n\nMatrix m1 = Matrix(3, 3, data);\n// Perform matrix operations here...\n</code></pre> <p>Warning</p> <p>The Matrix class takes ownership of the array passed through its constructor and only makes a shallow copy. This means that: - The array must be dynamically allocated (i.e., allocated on the heap) rather than on the stack. - You should not modify or delete the array after passing it to the Matrix constructor.</p>"},{"location":"user-guide/utils/math/#quaternion","title":"Quaternion","text":"<p>Our Quaternion class is adapted from Adafruit's <code>imu</code> namespace. It is used by the IMU to store orientation data. It supports vector operations such as addition, subtraction, and multiplication, as well as quaternion-specific operations like quaternion multiplication and conversion to/from Euler angles.</p> <pre><code>#include &lt;Math.h&gt;\n\n// Create a quaternion with specific components (w, x, y, z)\nQuaternion q1 = Quaternion(1.0, 0.0, 0.0, 0.0);\n\n// Normalize the quaternion to ensure valid rotation data\nq1.normalize();\n\n// Convert to Euler angles (roll, pitch, yaw)\nVector&lt;3&gt; euler = q1.toEuler();\n\n// Perform other quaternion operations here...\n</code></pre>"},{"location":"user-guide/utils/math/#vector","title":"Vector","text":"<p>The Vector class is used to represent a mathematical vector (not to be confused with the C++ <code>std::vector</code>). This Vector has a fixed length containing <code>double</code> values. It supports vector operations like addition, subtraction, multiplication, as well as dot products and cross products. It is also adapted from Adafruit's <code>imu</code> vector class.</p> <pre><code>#include &lt;Math.h&gt;\n\n// Create two 3D vectors\nVector&lt;3&gt; v1 = Vector(1.0, 2.0, 3.0);\nVector&lt;3&gt; v2 = Vector(3.0, 2.0, 1.0);\n\n// Compute the dot product\ndouble dotVal = v1.dot(v2); // 1*3 + 2*2 + 3*1 = 3 + 4 + 3 = 10\n\n// Compute the cross product\nVector crossVal = v1.cross(v2); // (2*1 - 3*2, 3*3 - 1*1, 1*2 - 2*3)\n\n// Perform additional vector operations as needed...\n</code></pre>"},{"location":"user-guide/utils/mmfssys/","title":"MMFSSystem","text":"<p>The MMFSSystem object is designed to make interacting with the MMFS library as simple as possible. You begin by defining an MMFSConfig object, configuring all of the parameters your flight code needs, and then passing that configuration object into an MMFSSystem object. Afterward, you only need to call the <code>init()</code> and <code>update()</code> functions. MMFSSystem will take care of everything else.</p>"},{"location":"user-guide/utils/mmfssys/#mmfsconfig","title":"MMFSConfig","text":"<p>The MMFSConfig object uses a builder-like pattern, making it easy to set up MMFS. The only configuration option that you must use in order to run MMFSSystem is to pass a derived State object with proper launch detection.</p>"},{"location":"user-guide/utils/mmfssys/#code-example-withstate","title":"Code Example: <code>withState(...)</code>","text":"<pre><code>#include &lt;MMFS.h&gt;\n#include &lt;MyCustomState.h&gt; // A user-defined State class that detects launch\n\n\nMyCustomState myState;\n\nMMFSConfig config = MMFSConfig()\n                    .withState(&amp;myState); // REQUIRED\n</code></pre> <p>Where <code>myState</code> is your derived State object that handles launch detection.</p>"},{"location":"user-guide/utils/mmfssys/#mmfsconfig-options","title":"MMFSConfig Options","text":"<p>Below is a refined list of the configuration methods available in MMFSConfig. Each returns a reference to the same MMFSConfig instance, allowing you to chain calls together:</p> <ul> <li> <p><code>withState(State *state)</code>   Adds a derived State (and its associated sensors) to MMFS. This is required for MMFSSystem to function properly.</p> </li> <li> <p><code>withUpdateRate(unsigned int updateRate)</code>   Sets an update rate in Hertz. (Default is <code>10</code>.) Mutually exclusive with update interval.</p> </li> <li> <p><code>withUpdateInterval(unsigned int updateInterval)</code>   Sets the update interval in milliseconds. (Default is <code>100</code>.) Mutually exclusive with update rate.</p> </li> <li> <p><code>withSensorBiasCorrectionDataLength(unsigned int sensorBiasCorrectionDataLength)</code>   Specifies the duration (in seconds) over which sensors will average data to correct for drift. This duration is affected by the update rate/interval. (Default is <code>2</code>.)</p> </li> <li> <p><code>withSensorBiasCorrectionDataIgnore(unsigned int sensorBiasCorrectionDataIgnore)</code>   Specifies the duration (in seconds) of the most recent data to ignore when performing drift correction. This duration is also affected by the update rate/interval. (Default is <code>1</code>.)</p> </li> <li> <p><code>withUsingSensorBiasCorrection(bool useBiasCorrection)</code>   Determines whether sensors will continuously re-zero themselves while on the ground. (Default is <code>false</code>.) Warning: This function requires working launch detection or data may not be accurate.</p> </li> <li> <p><code>withMaxPSRAMFiles(unsigned int maxPSRAMFiles)</code>   Sets the maximum number of files the PSRAM can store. There is some moderate memory overhead per file. (Default is <code>5</code>.)</p> </li> <li> <p><code>withPSRAMClusterSize(unsigned int psramClusterSize)</code>   Sets the cluster size for the FAT-style PSRAM system in bytes. You should not modify this unless you have a specific reason to do so. (Default is <code>62,500</code>.)</p> </li> <li> <p><code>withBuzzerPin(unsigned int buzzerPin)</code>   Sets the named <code>BUZZER</code> for use with <code>BlinkBuzz</code>. (No Default.)</p> </li> <li> <p><code>withBBPin(unsigned int bbPin)</code>   Adds a pin to <code>BlinkBuzz</code>. By default, no pins are added.</p> </li> <li> <p><code>withBBAsync(bool bbAsync, unsigned int queueSize = 50)</code>   Allows <code>BlinkBuzz</code> to use asynchronous features. This incurs moderate memory overhead based on the queue size (the number of state changes a pin can queue). (Default is <code>true</code> and <code>50</code>.)</p> </li> <li> <p><code>withCompressedFlightData(bool compressedData)</code>   Enables or disables compression of flight data while in flight to save PSRAM space. If <code>false</code>, full CSV strings are stored in PSRAM. (Default is <code>true</code>.)</p> </li> <li> <p><code>withUsePSRAM(bool usePSRAM)</code>   Enables or disables using PSRAM during flight. If <code>false</code>, all data is immediately written to the SD card. Disabling this also disables the pre-flight, full-data-rate buffer. (Default is <code>true</code>.) Warning: This requires working landing detection or data may not be saved.</p> </li> <li> <p><code>withReducedPreFlightDataRate(bool useReducedRate, unsigned int secondsBetweenRecords)</code>   Enables or disables reduced data rates before flight. (Default is <code>true</code>, <code>30</code> seconds.) Warning: This requires working launch detection or all data will remain at the reduced rate.</p> </li> <li> <p><code>withPreFlightBuffer(bool useBuffer, unsigned int duration)</code>   Sets a full-data-rate pre-flight data buffer in the PSRAM. This is useful if reduced pre-flight data rate is enabled. (Default is <code>true</code>, <code>30</code> seconds.)</p> </li> <li> <p><code>withOtherDataReporters(DataReporter **others)</code>   Adds additional DataReporter objects for flight data logging. Passing a State via <code>withState()</code> automatically captures that State\u2019s sensors, so adding them here might be redundant.</p> </li> <li> <p><code>withNoDefaultEventListener()</code>   Removes the default event handler from the event manager, useful if you have a custom one that alters default behavior.</p> </li> <li> <p><code>withLogPrefixFormatting(const char *prefix)</code>   Changes the formatting of the log prefix. You must use <code>$time</code> and <code>$logType</code> to reference the current log\u2019s time and log type. (Default is <code>\"$time - [$logType] \"</code>.)</p> </li> </ul>"},{"location":"user-guide/utils/mmfssys/#full-example","title":"Full Example","text":"<p>Below is a simple, hypothetical Arduino sketch illustrating how to use MMFSSystem with MMFSConfig:</p> <p><pre><code>#include &lt;Arduino.h&gt;\n#include &lt;MMFS.h&gt;\n#include &lt;MyCustomState.h&gt;  // Your derived State class\n#include &lt;MyCustomReporter.h&gt; // Additional DataReporter\n\n// Create instances\nMyCustomState myState;\nMyCustomReporter myReporter;\n\n// Create the configuration\nMMFSConfig config = MMFSConfig()\n    .withState(&amp;myState)    // Required for launch detection\n    .withUpdateRate(20)     // 20 Hz update\n    .withUsePSRAM(true)     // Use PSRAM in flight\n    .withCompressedFlightData(true)\n    .withPreFlightBuffer(true, 30)\n    .withOtherDataReporters({&amp;myReporter}) // Additional data reporters\n    .withLogPrefixFormatting(\"$time - [$logType]: \");\n\n// Create the system object\nMMFSSystem system = MMFSSystem(config);\n\nvoid setup() {\n    Serial.begin(115200);\n    // Initialize the system\n    system.init(); // (1)!\n}\n\nvoid loop() {\n    // Update the system\n    system.update();\n\n    // Your other code goes here...\n}\n</code></pre></p> <ol> <li>This function will call events based on whether or not State and Logger initialize successfully. They are automatically handed by the default event listener.</li> </ol>"},{"location":"user-guide/utils/test/","title":"Test page","text":""}]}